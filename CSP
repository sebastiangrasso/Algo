package csp;

import java.lang.reflect.Array;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.Set;
import java.util.ArrayList;
import java.util.List;

/**
 * CSP: Calendar Satisfaction Problem Solver
 * Provides a solution for scheduling some n meetings in a given
 * period of time and according to some unary and binary constraints
 * on the dates of each meeting.
 */
public class CSP {

    /**
     * Public interface for the CSP solver in which the number of meetings,
     * range of allowable dates for each meeting, and constraints on meeting
     * times are specified.
     * @param nMeetings The number of meetings that must be scheduled, indexed from 0 to n-1
     * @param rangeStart The start date (inclusive) of the domains of each of the n meeting-variables
     * @param rangeEnd The end date (inclusive) of the domains of each of the n meeting-variables
     * @param constraints Date constraints on the meeting times (unary and binary for this assignment)
     * @return A list of dates that satisfies each of the constraints for each of the n meetings,
     *         indexed by the variable they satisfy, or null if no solution exists.
     */
    public static List<LocalDate> solve (int nMeetings, LocalDate rangeStart, LocalDate rangeEnd, Set<DateConstraint> constraints) {
    	
    	ArrayList<ArrayList<LocalDate>> possDomains = new ArrayList<ArrayList<LocalDate>>(nMeetings);
    	ArrayList<LocalDate> inner = new ArrayList<LocalDate>();
    	for (int i=0; i < (rangeStart.until(rangeEnd, ChronoUnit.DAYS)+1); i++) {
    		inner.add(rangeStart.plusDays(i));
    	}
    	for (int i =0; i < nMeetings; i++) {
    		possDomains.add(inner);
    	}
    	
    	ArrayList<LocalDate> assignments = new ArrayList<LocalDate>(nMeetings);
    	
		for(int i =0; i<possDomains.size(); i++) {
			if (possDomains.get(i).isEmpty()) {
				return null;
			}
		}
		return recursiveBackTrackingSearch(0, assignments, possDomains, constraints);
    }
	public static ArrayList<LocalDate> recursiveBackTrackingSearch(int index, ArrayList<LocalDate> assignments, ArrayList<ArrayList<LocalDate>> possDomains, Set<DateConstraint> constraints) {
		ArrayList <LocalDate> result = null;
		if (assignments.isComplete())) { //some way of verifying assignments is complete
			result = assignments;
		} else {
			int unassigned = selectUnassignedVariable(assignments);
			for (LocalDate value : possDomains.get(unassigned)) {
				if (isConsistent(constraints, value)) {
					assignments.set(unassigned, value);
					result = recursiveBackTrackingSearch(index+1, assignments, possDomains, constraints);
						if (result != null)
							break;
					}
					info.restoreDomains(csp);
				}
				assignments.remove(var);
			}		
		return result;
	}

	public static int selectUnassignedVariable(ArrayList<LocalDate> assignments) {
		for (int i=0; i < assignments.size(); i++) {
			if (assignments.get(i) == null)
				return i;
		}
		return -1;
	}
	
	public static boolean isConsistent(Set<DateConstraint> constraints, LocalDate curr) {
		for (DateConstraint cons : constraints)
			if (isSatisfiedWith(cons,curr)) //method for verifying assignment fits constraints
				return false;
		return true;
	}
	
	public static boolean isSatisfiedWith(DateConstraint constraint, LocalDate curr) {
		return true;
	}


    
}
